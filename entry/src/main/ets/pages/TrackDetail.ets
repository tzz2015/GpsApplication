import { router } from '@kit.ArkUI';
import { MapComponent, mapCommon, map } from '@kit.MapKit';
import { AsyncCallback } from '@kit.BasicServicesKit';
import { common } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { TrackStore } from '../common/TrackStore';
import { TrackModel } from '../common/TrackModel';
import { AuthStore } from '../common/AuthStore';
import { NavBar } from '../common/NavBar';
import { SyncService } from '../common/SyncService';

const LOG_DOMAIN = 0x0000;
const LOG_TAG = 'TrackDetail';

/** è·¯ç”±å‚æ•°æ¥å£ */
interface TrackDetailParams {
  trackId: string;
  title: string;
  isPublicView?: boolean;
}

/**
 * P1-4 è½¨è¿¹è¯¦æƒ…é¡µ
 * å·²å®ŒæˆçŠ¶æ€ï¼šåœ°å›¾ + ç»Ÿè®¡ + å¯è§èŒƒå›´ + æ‰“å¡ç‚¹æ—¶é—´è½´ + åˆ†äº«/åˆ é™¤
 * ç¼–è¾‘ä¸­çŠ¶æ€ï¼šåœ°å›¾ + ç»Ÿè®¡ + æœªå®Œæˆæç¤º + æ‰“å¡ç‚¹æ—¶é—´è½´ + ç»§ç»­è®°å½•/åˆ é™¤
 */
@Entry
@Component
struct TrackDetail {
  @State track: TrackModel.Track | null = null;
  @State tombSpots: TrackModel.TombSpot[] = [];
  @State isEditing: boolean = false;
  @State isPrivate: boolean = true;
  @State isOwner: boolean = false;
  @State isPublicView: boolean = false;
  @State mapCenterLat: number = 23.7275;
  @State mapCenterLng: number = 108.3426;
  @State showEditTitleDialog: boolean = false;
  @State showEditSpotNameDialog: boolean = false;
  @State editInputText: string = '';
  @State editingSpotId: string = '';
  private trackId: string = '';
  private mapCallback?: AsyncCallback<map.MapComponentController>;
  private mapController?: map.MapComponentController;
  private mapReady: boolean = false;
  private dataReady: boolean = false;

  aboutToAppear(): void {
    const params = router.getParams() as TrackDetailParams | undefined;
    if (params) {
      this.trackId = params.trackId || '';
      this.isPublicView = params.isPublicView || false;
    }
    this.loadData();
    this.mapCallback = async (err: Error, controller: map.MapComponentController) => {
      if (!err) {
        this.mapController = controller;
        this.mapReady = true;
        // å¦‚æœæ•°æ®å·²åŠ è½½å®Œï¼Œç«‹å³ç»˜åˆ¶è½¨è¿¹
        if (this.dataReady) {
          this.moveCameraAndDraw();
        }
      }
    };
  }

  onPageShow(): void {
    this.loadData();
    if (this.mapController) {
      this.mapController.show();
      // é‡æ–°ç»˜åˆ¶è½¨è¿¹å’Œæ‰“å¡ç‚¹ï¼ˆä»ç¼–è¾‘/è®°å½•è¿”å›æ—¶å¯èƒ½æœ‰æ–°æ•°æ®ï¼‰
      this.moveCameraAndDraw();
    }
  }

  onPageHide(): void {
    if (this.mapController) {
      this.mapController.hide();
    }
  }

  private async loadData(): Promise<void> {
    const context = this.getUIContext().getHostContext() as common.Context;
    const t = await TrackStore.getTrackById(context, this.trackId);
    if (t) {
      this.track = t;
      this.isEditing = t.status === TrackModel.TRACK_STATUS_EDITING;
      this.isPrivate = t.visibility !== TrackModel.VISIBILITY_PUBLIC;
      if (t.startLat !== 0) {
        this.mapCenterLat = t.startLat;
        this.mapCenterLng = t.startLng;
      }
      // åˆ¤æ–­å½“å‰ç”¨æˆ·æ˜¯å¦ä¸ºè½¨è¿¹åˆ›å»ºè€…
      const user = await AuthStore.getCurrentUser(context);
      if (user && t.ownerUserId === user.userId) {
        this.isOwner = true;
      }
    }
    this.tombSpots = await TrackStore.getTombSpotsByTrackId(context, this.trackId);
    this.dataReady = true;

    // å¦‚æœåœ°å›¾å·²å°±ç»ªï¼Œç§»åŠ¨ç›¸æœºå¹¶ç»˜åˆ¶è½¨è¿¹
    if (this.mapReady) {
      this.moveCameraAndDraw();
    }
  }

  /** WGS84 åæ ‡è½¬ GCJ02ï¼ˆåä¸ºåœ°å›¾ä½¿ç”¨ GCJ02ï¼‰ */
  private async convertToGCJ02(lat: number, lng: number): Promise<mapCommon.LatLng> {
    try {
      const wgs84: mapCommon.LatLng = { latitude: lat, longitude: lng };
      const gcj02: mapCommon.LatLng = await map.convertCoordinate(
        mapCommon.CoordinateType.WGS84,
        mapCommon.CoordinateType.GCJ02,
        wgs84
      );
      return gcj02;
    } catch (e) {
      hilog.error(LOG_DOMAIN, LOG_TAG, 'convertToGCJ02 error: %{public}s', JSON.stringify(e));
      return { latitude: lat, longitude: lng };
    }
  }

  /** ç»˜åˆ¶è½¨è¿¹ + æ‰“å¡ç‚¹ï¼Œå¹¶è‡ªåŠ¨é€‚é…ç›¸æœºè®©æ•´æ¡è½¨è¿¹å±…ä¸­ */
  private async moveCameraAndDraw(): Promise<void> {
    if (!this.mapController) {
      return;
    }
    await this.drawTrackOnMap();
    await this.drawSpotMarkers();
  }

  /** ç»˜åˆ¶è½¨è¿¹æŠ˜çº¿ + èµ·ç»ˆç‚¹æ ‡è®°ï¼Œå¹¶è‡ªåŠ¨å°†ç›¸æœºé€‚é…åˆ°è½¨è¿¹èŒƒå›´ */
  private async drawTrackOnMap(): Promise<void> {
    if (!this.mapController) {
      return;
    }
    const context = this.getUIContext().getHostContext() as common.Context;
    const points = await TrackStore.getTrackPointsByTrackId(context, this.trackId);

    hilog.info(LOG_DOMAIN, LOG_TAG, 'drawTrackOnMap start: GPS pts=%{public}d, spots=%{public}d',
      points.length, this.tombSpots.length);

    // æ”¶é›†æ‰€æœ‰éœ€è¦æ˜¾ç¤ºåœ¨åœ°å›¾ä¸Šçš„åæ ‡ï¼Œç”¨äºåŒ…å›´ç›’è®¡ç®—
    const allLatLngs: mapCommon.LatLng[] = [];

    // ===== 1. ç»˜åˆ¶è½¨è¿¹æŠ˜çº¿ =====
    if (points.length >= 2) {
      // æ–¹æ¡ˆ Aï¼šGPS è½¨è¿¹ç‚¹å……è¶³ï¼Œç”»ç²¾ç¡®æŠ˜çº¿
      const gcj02Points: mapCommon.LatLng[] = [];
      for (let i = 0; i < points.length; i++) {
        const converted = await this.convertToGCJ02(points[i].latitude, points[i].longitude);
        gcj02Points.push(converted);
        allLatLngs.push(converted);
      }
      try {
        await this.mapController.addPolyline({
          points: gcj02Points,
          color: 0xFFFF6B35,
          width: 12,
          visible: true
        });
        hilog.info(LOG_DOMAIN, LOG_TAG, 'addPolyline GPS: %{public}d points drawn', gcj02Points.length);
      } catch (e) {
        hilog.error(LOG_DOMAIN, LOG_TAG, 'addPolyline GPS error: %{public}s', JSON.stringify(e));
      }
    } else {
      // æ–¹æ¡ˆ Bï¼šGPS è½¨è¿¹ç‚¹ä¸è¶³ï¼Œç”¨ èµ·ç‚¹â†’æ‰“å¡ç‚¹â†’ç»ˆç‚¹ çš„åæ ‡è¿çº¿ä½œä¸ºå›é€€è·¯çº¿
      hilog.info(LOG_DOMAIN, LOG_TAG, 'GPS pts < 2, fallback to waypoints route');
      const waypoints: mapCommon.LatLng[] = [];

      // èµ·ç‚¹åæ ‡
      if (this.track && this.track.startLat !== 0) {
        const p = await this.convertToGCJ02(this.track.startLat, this.track.startLng);
        waypoints.push(p);
      }
      // æ‰“å¡ç‚¹åæ ‡ï¼ˆæŒ‰ orderIndex æ’åºï¼‰
      const sortedSpots: TrackModel.TombSpot[] = [];
      for (let i = 0; i < this.tombSpots.length; i++) {
        sortedSpots.push(this.tombSpots[i]);
      }
      sortedSpots.sort((a: TrackModel.TombSpot, b: TrackModel.TombSpot): number => a.orderIndex - b.orderIndex);
      for (let i = 0; i < sortedSpots.length; i++) {
        if (sortedSpots[i].latitude !== 0) {
          const p = await this.convertToGCJ02(sortedSpots[i].latitude, sortedSpots[i].longitude);
          waypoints.push(p);
        }
      }
      // ç»ˆç‚¹åæ ‡
      if (this.track && this.track.endLat !== 0 && this.track.endName.length > 0) {
        const p = await this.convertToGCJ02(this.track.endLat, this.track.endLng);
        waypoints.push(p);
      }

      // æœ‰è‡³å°‘ 2 ä¸ªèˆªç‚¹æ‰èƒ½ç”»çº¿
      if (waypoints.length >= 2) {
        try {
          await this.mapController.addPolyline({
            points: waypoints,
            color: 0xFFFF6B35,
            width: 10,
            visible: true
          });
          hilog.info(LOG_DOMAIN, LOG_TAG, 'addPolyline waypoints: %{public}d waypoints drawn', waypoints.length);
        } catch (e) {
          hilog.error(LOG_DOMAIN, LOG_TAG, 'addPolyline waypoints error: %{public}s', JSON.stringify(e));
        }
      }
      for (let i = 0; i < waypoints.length; i++) {
        allLatLngs.push(waypoints[i]);
      }
    }

    // ===== 2. èµ·ç‚¹æ ‡è®°ï¼ˆå§‹ç»ˆç»˜åˆ¶ï¼‰ =====
    if (this.track && this.track.startLat !== 0) {
      try {
        const startP = await this.convertToGCJ02(this.track.startLat, this.track.startLng);
        await this.mapController.addMarker({
          position: startP,
          title: this.track.startName || 'èµ·ç‚¹',
          visible: true
        });
        allLatLngs.push(startP);
      } catch (e) {
        hilog.info(LOG_DOMAIN, LOG_TAG, 'addMarker start: %{public}s', JSON.stringify(e));
      }
    }

    // ===== 3. ç»ˆç‚¹æ ‡è®°ï¼ˆè½¨è¿¹å·²å®Œæˆæ—¶ç»˜åˆ¶ï¼‰ =====
    if (this.track && this.track.endLat !== 0 && this.track.endName.length > 0) {
      try {
        const endP = await this.convertToGCJ02(this.track.endLat, this.track.endLng);
        await this.mapController.addMarker({
          position: endP,
          title: this.track.endName || 'ç»ˆç‚¹',
          visible: true
        });
        allLatLngs.push(endP);
      } catch (e) {
        hilog.info(LOG_DOMAIN, LOG_TAG, 'addMarker end: %{public}s', JSON.stringify(e));
      }
    }

    // ===== 4. æ‰“å¡ç‚¹åæ ‡åŠ å…¥åŒ…å›´ç›’ =====
    for (let i = 0; i < this.tombSpots.length; i++) {
      if (this.tombSpots[i].latitude !== 0) {
        const spotP = await this.convertToGCJ02(this.tombSpots[i].latitude, this.tombSpots[i].longitude);
        allLatLngs.push(spotP);
      }
    }

    // ===== 5. è®¡ç®—åŒ…å›´ç›’å¹¶é€‚é…ç›¸æœºï¼Œè®©è½¨è¿¹å±…ä¸­ =====
    if (allLatLngs.length > 0) {
      this.fitCameraToBounds(allLatLngs);
    } else {
      // æ— ä»»ä½•åæ ‡ï¼Œå›é€€åˆ°é»˜è®¤èµ·ç‚¹
      try {
        const gcj02 = await this.convertToGCJ02(this.mapCenterLat, this.mapCenterLng);
        const cameraPosition: mapCommon.CameraPosition = {
          target: gcj02,
          zoom: 15,
          tilt: 0,
          bearing: 0
        };
        this.mapController.moveCamera(map.newCameraPosition(cameraPosition));
      } catch (e) {
        hilog.error(LOG_DOMAIN, LOG_TAG, 'moveCamera fallback: %{public}s', JSON.stringify(e));
      }
    }

    hilog.info(LOG_DOMAIN, LOG_TAG, 'drawTrackOnMap done: GPS=%{public}d, spots=%{public}d, bounds=%{public}d',
      points.length, this.tombSpots.length, allLatLngs.length);
  }

  /** åœ¨åœ°å›¾ä¸Šæ ‡è®°æ‰€æœ‰æ‰“å¡ç‚¹ï¼ˆä¼˜å…ˆç”¨å°åœ†åœˆï¼Œå›é€€åˆ°åŠé€æ˜æ ‡è®°ï¼‰ */
  private async drawSpotMarkers(): Promise<void> {
    if (!this.mapController) {
      return;
    }
    for (let i = 0; i < this.tombSpots.length; i++) {
      const spot = this.tombSpots[i];
      if (spot.latitude === 0 && spot.longitude === 0) {
        continue;
      }
      const gcj02 = await this.convertToGCJ02(spot.latitude, spot.longitude);
      let circleOk = false;
      // ä¼˜å…ˆç”¨å°åœ†åœˆæ ‡è®°æ‰“å¡ç‚¹ï¼ˆæ¯”é»˜è®¤å¤§å›¾é’‰æ›´ç²¾è‡´ï¼‰
      try {
        await this.mapController.addCircle({
          center: gcj02,
          radius: 6,
          fillColor: 0xCC4A90D9,
          strokeColor: 0xFFFFFFFF,
          strokeWidth: 3,
          visible: true
        });
        circleOk = true;
      } catch (e) {
        hilog.info(LOG_DOMAIN, LOG_TAG, 'addCircle[%{public}d] fallback to marker: %{public}s', i, JSON.stringify(e));
      }
      // æ·»åŠ æ ‡è®°ï¼šåœ†åœˆæˆåŠŸåˆ™å‡ ä¹éšè—å›¾é’‰ï¼ˆä»…ä¿ç•™å¯ç‚¹å‡»æ ‡é¢˜ï¼‰ï¼Œå¦åˆ™ç”¨åŠé€æ˜å›¾é’‰
      try {
        await this.mapController.addMarker({
          position: gcj02,
          title: spot.name,
          visible: true,
          alpha: circleOk ? 0.01 : 0.7
        });
      } catch (e) {
        hilog.info(LOG_DOMAIN, LOG_TAG, 'addSpotMarker[%{public}d]: %{public}s', i, JSON.stringify(e));
      }
    }
  }

  /** æ ¹æ®åæ ‡é›†åˆè®¡ç®—åŒ…å›´ç›’ï¼Œç§»åŠ¨ç›¸æœºä½¿æ‰€æœ‰ç‚¹å±…ä¸­å¯è§ */
  private fitCameraToBounds(points: mapCommon.LatLng[]): void {
    if (!this.mapController || points.length === 0) {
      return;
    }
    try {
      let minLat = points[0].latitude;
      let maxLat = points[0].latitude;
      let minLng = points[0].longitude;
      let maxLng = points[0].longitude;
      for (let i = 1; i < points.length; i++) {
        const p = points[i];
        if (p.latitude < minLat) {
          minLat = p.latitude;
        }
        if (p.latitude > maxLat) {
          maxLat = p.latitude;
        }
        if (p.longitude < minLng) {
          minLng = p.longitude;
        }
        if (p.longitude > maxLng) {
          maxLng = p.longitude;
        }
      }
      // è®¡ç®—ä¸­å¿ƒç‚¹
      const centerLat = (minLat + maxLat) / 2;
      const centerLng = (minLng + maxLng) / 2;
      // æ ¹æ®èŒƒå›´è®¡ç®—åˆé€‚çš„ç¼©æ”¾ç­‰çº§
      const latDiff = maxLat - minLat;
      const lngDiff = maxLng - minLng;
      const maxDiff = Math.max(latDiff, lngDiff);
      let zoom = 16;
      if (maxDiff > 0.1) {
        zoom = 10;
      } else if (maxDiff > 0.05) {
        zoom = 11;
      } else if (maxDiff > 0.02) {
        zoom = 12;
      } else if (maxDiff > 0.01) {
        zoom = 13;
      } else if (maxDiff > 0.005) {
        zoom = 14;
      } else if (maxDiff > 0.002) {
        zoom = 15;
      } else {
        zoom = 16;
      }
      const cameraPosition: mapCommon.CameraPosition = {
        target: { latitude: centerLat, longitude: centerLng },
        zoom: zoom,
        tilt: 0,
        bearing: 0
      };
      this.mapController.moveCamera(map.newCameraPosition(cameraPosition));
    } catch (e) {
      hilog.error(LOG_DOMAIN, LOG_TAG, 'fitCameraToBounds error: %{public}s', JSON.stringify(e));
    }
  }

  /** åˆ‡æ¢å¯è§èŒƒå›´ */
  private async toggleVisibility(): Promise<void> {
    this.isPrivate = !this.isPrivate;
    const context = this.getUIContext().getHostContext() as common.Context;
    await TrackStore.updateTrack(context, this.trackId, {
      visibility: this.isPrivate ? TrackModel.VISIBILITY_PRIVATE : TrackModel.VISIBILITY_PUBLIC
    });
    // åŒæ­¥å¯è§æ€§å˜æ›´åˆ°äº‘ç«¯
    SyncService.syncTrack(context, this.trackId).catch((e: Error) => {
      hilog.warn(LOG_DOMAIN, LOG_TAG, 'Sync visibility change: %{public}s', JSON.stringify(e));
    });
  }

  /** åˆ é™¤è½¨è¿¹ */
  private showDeleteConfirm(): void {
    AlertDialog.show({
      title: 'åˆ é™¤è½¨è¿¹',
      message: 'ç¡®å®šåˆ é™¤è¿™æ¡è½¨è¿¹ï¼Ÿåˆ é™¤åæ— æ³•æ¢å¤ã€‚',
      primaryButton: { value: 'å–æ¶ˆ', action: () => {} },
      secondaryButton: {
        value: 'ç¡®å®šåˆ é™¤',
        fontColor: $r('app.color.destructive'),
        action: async () => {
          const context = this.getUIContext().getHostContext() as common.Context;
          await TrackStore.deleteTrack(context, this.trackId);
          // åŒæ—¶åˆ é™¤äº‘ç«¯æ•°æ®
          SyncService.deleteCloudTrack(this.trackId).catch((e: Error) => {
            hilog.warn(0x0000, 'TrackDetail', 'Delete cloud track: %{public}s', JSON.stringify(e));
          });
          router.back();
        }
      }
    });
  }

  build() {
    Stack() {
    Column() {
      NavBar({ title: this.track ? this.track.title : 'è½¨è¿¹è¯¦æƒ…', showBack: true });

      Scroll() {
        Column() {
          // åœ°å›¾åŒºåŸŸ
          Stack() {
            MapComponent({
              mapOptions: {
                position: {
                  target: { latitude: this.mapCenterLat, longitude: this.mapCenterLng },
                  zoom: 15
                },
                myLocationControlsEnabled: false
              },
              mapCallback: this.mapCallback
            })
              .width('100%')
              .height('100%');
          }
          .width('100%')
          .height(200)
          .margin({ left: 16, right: 16, top: 8 })
          .borderRadius(12)
          .clip(true);

          // è½¨è¿¹ä¿¡æ¯
          if (this.track) {
            Column({ space: 8 }) {
              Row({ space: 8 }) {
                Text(this.track.title)
                  .fontSize(20)
                  .fontWeight(FontWeight.Bold)
                  .fontColor($r('app.color.label_primary'))
                  .layoutWeight(1);
                // ç¼–è¾‘å›¾æ ‡ï¼ˆä»…åˆ›å»ºè€…å¯è§ï¼‰
                if (this.isOwner && !this.isPublicView) {
                  Text('âœï¸')
                    .fontSize(16)
                    .onClick(() => {
                      this.editInputText = this.track ? this.track.title : '';
                      this.showEditTitleDialog = true;
                    });
                }
                if (this.isEditing) {
                  Text('ç¼–è¾‘ä¸­')
                    .fontSize(11)
                    .fontWeight(FontWeight.Medium)
                    .fontColor($r('app.color.warning'))
                    .backgroundColor($r('app.color.warning_light'))
                    .padding({ left: 8, right: 8, top: 2, bottom: 2 })
                    .borderRadius(10);
                } else {
                  Text('å·²å®Œæˆ')
                    .fontSize(11)
                    .fontWeight(FontWeight.Medium)
                    .fontColor($r('app.color.success'))
                    .backgroundColor($r('app.color.success_light'))
                    .padding({ left: 8, right: 8, top: 2, bottom: 2 })
                    .borderRadius(10);
                }
              }
              .width('100%');

              if (this.track.description.length > 0) {
                Text(this.track.description)
                  .fontSize(13)
                  .fontColor($r('app.color.label_secondary'))
                  .lineHeight(20)
                  .width('100%');
              }

              Text(TrackModel.formatDate(this.track.createdAt))
                .fontSize(12)
                .fontColor($r('app.color.label_tertiary'));

              // ç»Ÿè®¡æ•°æ®
              Row() {
                this.StatItem(TrackModel.formatDistance(this.track.totalDistance), 'æ€»é‡Œç¨‹');
                Divider().vertical(true).height(30).color($r('app.color.separator'));
                this.StatItem(TrackModel.formatDuration(this.track.totalDuration), 'ç”¨æ—¶');
                Divider().vertical(true).height(30).color($r('app.color.separator'));
                this.StatItem(this.track.maxAltitude.toString() + 'm', 'æœ€é«˜æµ·æ‹”');
                Divider().vertical(true).height(30).color($r('app.color.separator'));
                this.StatItem(this.tombSpots.length.toString(), 'æ‰“å¡ç‚¹');
              }
              .width('100%')
              .padding(12)
              .backgroundColor($r('app.color.app_background'))
              .borderRadius(12)
              .margin({ top: 8 });
            }
            .width('100%')
            .padding(16)
            .backgroundColor($r('app.color.card_background'));

            // ç¼–è¾‘ä¸­çŠ¶æ€æç¤º
            if (this.isEditing) {
              Row({ space: 10 }) {
                Text('âš ')
                  .fontSize(18);
                Column({ space: 2 }) {
                  Text('è½¨è¿¹å°šæœªå®Œæˆ')
                    .fontSize(14)
                    .fontWeight(FontWeight.Medium)
                    .fontColor('#B45309');
                  Text('è¯·ç»§ç»­è®°å½•å¹¶è®¾ç½®ç»ˆç‚¹æ¥å®Œæˆæ­¤è½¨è¿¹')
                    .fontSize(12)
                    .fontColor('#B45309');
                }
              }
              .width('100%')
              .padding(14)
              .margin({ left: 16, right: 16, top: 12 })
              .backgroundColor($r('app.color.warning_light'))
              .borderRadius(12);
            }

            // å¯è§èŒƒå›´ï¼ˆä»…å·²å®ŒæˆçŠ¶æ€ï¼‰
            if (!this.isEditing) {
              Row() {
                Row({ space: 10 }) {
                  Text('ğŸ”’')
                    .fontSize(18);
                  Column({ space: 2 }) {
                    Text('å¯è§èŒƒå›´')
                      .fontSize(14)
                      .fontWeight(FontWeight.Medium)
                      .fontColor($r('app.color.label_primary'));
                    Text('è®¾ç½®è½¨è¿¹å¯¹å…¶ä»–äººæ˜¯å¦å¯è§')
                      .fontSize(12)
                      .fontColor($r('app.color.label_tertiary'));
                  }
                }
                .layoutWeight(1);

                Row() {
                  Text('ç§æœ‰')
                    .fontSize(12)
                    .fontWeight(FontWeight.Medium)
                    .fontColor(this.isPrivate ? Color.White : $r('app.color.label_tertiary'))
                    .padding({ left: 14, right: 14, top: 6, bottom: 6 })
                    .backgroundColor(this.isPrivate ? $r('app.color.primary') : Color.Transparent)
                    .borderRadius(20)
                    .onClick(() => {
                      if (!this.isPrivate) {
                        this.toggleVisibility();
                      }
                    });
                  Text('å…¬å¼€')
                    .fontSize(12)
                    .fontWeight(FontWeight.Medium)
                    .fontColor(!this.isPrivate ? Color.White : $r('app.color.label_tertiary'))
                    .padding({ left: 14, right: 14, top: 6, bottom: 6 })
                    .backgroundColor(!this.isPrivate ? $r('app.color.primary') : Color.Transparent)
                    .borderRadius(20)
                    .onClick(() => {
                      if (this.isPrivate) {
                        this.toggleVisibility();
                      }
                    });
                }
                .padding(3)
                .backgroundColor($r('app.color.app_background'))
                .borderRadius(20);
              }
              .width('100%')
              .padding(14)
              .margin({ left: 16, right: 16, top: 12 })
              .backgroundColor($r('app.color.card_background'))
              .borderRadius(12)
              .shadow({ radius: 4, color: '#0D000000', offsetX: 0, offsetY: 1 });
            }

            // è·¯çº¿è¯¦æƒ…ï¼ˆæ‰“å¡ç‚¹æ—¶é—´è½´ï¼‰
            Column() {
              Text('ğŸ“ è·¯çº¿è¯¦æƒ…')
                .fontSize(16)
                .fontWeight(FontWeight.Bold)
                .fontColor($r('app.color.label_primary'))
                .margin({ bottom: 12 })
                .width('100%');

              // èµ·ç‚¹
              if (this.track && this.track.startName.length > 0) {
                this.TimelineItem('ğŸŒ± ' + this.track.startName, 'èµ·ç‚¹',
                  TrackModel.formatDate(this.track.createdAt), true, false, '', false);
              }

              // æ‰“å¡ç‚¹
              ForEach(this.tombSpots, (spot: TrackModel.TombSpot, index: number) => {
                this.TimelineItem(
                  (index + 1).toString() + ' ' + spot.name,
                  '',
                  TrackModel.formatDate(spot.createdAt) + ' Â· æµ·æ‹” ' + spot.altitude.toString() + 'm',
                  false, false, spot.tombId, this.isOwner && !this.isPublicView
                );
              }, (spot: TrackModel.TombSpot) => spot.tombId);

              // ç»ˆç‚¹æˆ–ç­‰å¾…
              if (this.isEditing) {
                Row() {
                  Text('â³ ç­‰å¾…ç»§ç»­è®°å½•...')
                    .fontSize(14)
                    .fontColor($r('app.color.label_tertiary'));
                }
                .width('100%')
                .padding(12)
                .margin({ left: 28 })
                .backgroundColor($r('app.color.app_background'))
                .borderRadius(10)
                .borderWidth(1.5)
                .borderColor($r('app.color.separator'))
                .borderStyle(BorderStyle.Dashed);
              } else if (this.track && this.track.endName.length > 0) {
                this.TimelineItem('ğŸ ' + this.track.endName, 'ç»ˆç‚¹',
                  '', false, true, '', false);
              }
            }
            .width('100%')
            .padding(16)
            .margin({ top: 8 });

            // åº•éƒ¨æ“ä½œ
            Column({ space: 8 }) {
              if (this.isEditing) {
                Button('â–¶ ç»§ç»­è®°å½•')
                  .width('100%')
                  .height(50)
                  .fontSize(17)
                  .fontWeight(FontWeight.Medium)
                  .fontColor(Color.White)
                  .backgroundColor($r('app.color.accent'))
                  .borderRadius(25)
                  .onClick(() => {
                    router.pushUrl({
                      url: 'pages/TrackRecord',
                      params: { trackId: this.trackId, title: this.track ? this.track.title : '' }
                    });
                  });
              } else {
                Button('åˆ†äº«è½¨è¿¹')
                  .width('100%')
                  .height(50)
                  .fontSize(17)
                  .fontWeight(FontWeight.Medium)
                  .fontColor(Color.White)
                  .backgroundColor($r('app.color.primary'))
                  .borderRadius(25)
                  .onClick(() => {
                    // TODO: åˆ†äº«åŠŸèƒ½
                  });
              }
              Button('åˆ é™¤è½¨è¿¹')
                .width('100%')
                .height(44)
                .fontSize(15)
                .fontColor($r('app.color.destructive'))
                .backgroundColor(Color.Transparent)
                .borderWidth(1.5)
                .borderColor($r('app.color.destructive'))
                .borderRadius(22)
                .onClick(() => {
                  this.showDeleteConfirm();
                });
            }
            .width('100%')
            .padding({ left: 16, right: 16, bottom: 40 });
          }
        }
        .width('100%');
      }
      .layoutWeight(1)
      .scrollBar(BarState.Off)
      .backgroundColor($r('app.color.app_background'));
    }
    .width('100%')
    .height('100%')
    .backgroundColor($r('app.color.app_background'));

    // ç¼–è¾‘æ ‡é¢˜å¼¹çª—
    if (this.showEditTitleDialog) {
      Column() {
        Column() {
          Text('ç¼–è¾‘è½¨è¿¹åç§°')
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor($r('app.color.label_primary'))
            .margin({ bottom: 16 });
          TextInput({ placeholder: 'è½¨è¿¹åç§°', text: this.editInputText })
            .onChange((value: string) => {
              this.editInputText = value;
            })
            .width('100%')
            .height(44)
            .fontSize(15)
            .backgroundColor($r('app.color.app_background'))
            .borderRadius(10)
            .padding({ left: 12, right: 12 })
            .margin({ bottom: 16 });
          Row({ space: 12 }) {
            Button('å–æ¶ˆ')
              .layoutWeight(1)
              .height(44)
              .fontSize(15)
              .fontColor($r('app.color.primary'))
              .backgroundColor($r('app.color.primary_light'))
              .borderRadius(22)
              .onClick(() => {
                this.showEditTitleDialog = false;
                this.editInputText = '';
              });
            Button('ä¿å­˜')
              .layoutWeight(1)
              .height(44)
              .fontSize(15)
              .fontColor(Color.White)
              .backgroundColor($r('app.color.primary'))
              .borderRadius(22)
              .onClick(() => {
                this.saveEditedTitle();
              });
          }
          .width('100%');
        }
        .width(300)
        .padding(24)
        .backgroundColor($r('app.color.card_background'))
        .borderRadius(20)
        .shadow({ radius: 24, color: '#33000000', offsetX: 0, offsetY: 8 });
      }
      .width('100%')
      .height('100%')
      .backgroundColor('#66000000')
      .justifyContent(FlexAlign.Center)
      .zIndex(100);
    }

    // ç¼–è¾‘æ‰“å¡ç‚¹åç§°å¼¹çª—
    if (this.showEditSpotNameDialog) {
      Column() {
        Column() {
          Text('ç¼–è¾‘æ‰“å¡ç‚¹åç§°')
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor($r('app.color.label_primary'))
            .margin({ bottom: 16 });
          TextInput({ placeholder: 'æ‰“å¡ç‚¹åç§°', text: this.editInputText })
            .onChange((value: string) => {
              this.editInputText = value;
            })
            .width('100%')
            .height(44)
            .fontSize(15)
            .backgroundColor($r('app.color.app_background'))
            .borderRadius(10)
            .padding({ left: 12, right: 12 })
            .margin({ bottom: 16 });
          Row({ space: 12 }) {
            Button('å–æ¶ˆ')
              .layoutWeight(1)
              .height(44)
              .fontSize(15)
              .fontColor($r('app.color.primary'))
              .backgroundColor($r('app.color.primary_light'))
              .borderRadius(22)
              .onClick(() => {
                this.showEditSpotNameDialog = false;
                this.editInputText = '';
                this.editingSpotId = '';
              });
            Button('ä¿å­˜')
              .layoutWeight(1)
              .height(44)
              .fontSize(15)
              .fontColor(Color.White)
              .backgroundColor($r('app.color.primary'))
              .borderRadius(22)
              .onClick(() => {
                this.saveEditedSpotName();
              });
          }
          .width('100%');
        }
        .width(300)
        .padding(24)
        .backgroundColor($r('app.color.card_background'))
        .borderRadius(20)
        .shadow({ radius: 24, color: '#33000000', offsetX: 0, offsetY: 8 });
      }
      .width('100%')
      .height('100%')
      .backgroundColor('#66000000')
      .justifyContent(FlexAlign.Center)
      .zIndex(100);
    }
    }
    .width('100%')
    .height('100%');
  }

  @Builder
  StatItem(value: string, label: string) {
    Column({ space: 4 }) {
      Text(value)
        .fontSize(18)
        .fontWeight(FontWeight.Bold)
        .fontColor($r('app.color.label_primary'));
      Text(label)
        .fontSize(11)
        .fontColor($r('app.color.label_tertiary'));
    }
    .layoutWeight(1)
    .alignItems(HorizontalAlign.Center);
  }

  @Builder
  TimelineItem(name: string, tag: string, meta: string, isStart: boolean, isEnd: boolean, tombId: string, canEditName: boolean) {
    Row({ space: 12 }) {
      // æ—¶é—´è½´åœ†ç‚¹
      Column() {
        Circle({ width: 10, height: 10 })
          .fill(isStart ? $r('app.color.success') : (isEnd ? $r('app.color.destructive') : $r('app.color.primary')));
      }
      .width(10)
      .margin({ top: 4 });

      // å†…å®¹
      Column({ space: 4 }) {
        Row({ space: 6 }) {
          Text(name)
            .fontSize(14)
            .fontWeight(FontWeight.Medium)
            .fontColor($r('app.color.label_primary'))
            .layoutWeight(1);
          if (tag.length > 0) {
            Text(tag)
              .fontSize(10)
              .fontWeight(FontWeight.Medium)
              .fontColor(isStart ? $r('app.color.success') : $r('app.color.destructive'))
              .backgroundColor(isStart ? $r('app.color.success_light') : '#FFE8E6')
              .padding({ left: 6, right: 6, top: 2, bottom: 2 })
              .borderRadius(4);
          }
          // ç¼–è¾‘æ‰“å¡ç‚¹åç§°å›¾æ ‡ï¼ˆä»…åˆ›å»ºè€…ï¼‰
          if (canEditName && tombId.length > 0) {
            Text('âœï¸')
              .fontSize(14)
              .onClick(() => {
                // ä»æ‰“å¡ç‚¹åˆ—è¡¨ä¸­æ‰¾åˆ°å¯¹åº”åç§°
                for (let i = 0; i < this.tombSpots.length; i++) {
                  if (this.tombSpots[i].tombId === tombId) {
                    this.editInputText = this.tombSpots[i].name;
                    break;
                  }
                }
                this.editingSpotId = tombId;
                this.showEditSpotNameDialog = true;
              });
          }
        }
        if (meta.length > 0) {
          Text(meta)
            .fontSize(12)
            .fontColor($r('app.color.label_tertiary'));
        }
      }
      .layoutWeight(1)
      .padding(12)
      .backgroundColor($r('app.color.card_background'))
      .borderRadius(10)
      .shadow({ radius: 2, color: '#0A000000', offsetX: 0, offsetY: 1 })
      .onClick(() => {
        if (tombId.length > 0) {
          router.pushUrl({
            url: 'pages/TombSpotDetail',
            params: {
              tombId: tombId,
              trackId: this.trackId,
              trackTitle: this.track ? this.track.title : '',
              fromRecording: false
            }
          });
        }
      });
    }
    .width('100%')
    .alignItems(VerticalAlign.Top)
    .margin({ bottom: 8, left: 12 });
  }

  /** ä¿å­˜ç¼–è¾‘åçš„æ ‡é¢˜ */
  private async saveEditedTitle(): Promise<void> {
    const newTitle = this.editInputText.trim();
    if (newTitle.length === 0 || !this.track) {
      return;
    }
    this.showEditTitleDialog = false;
    const context = this.getUIContext().getHostContext() as common.Context;
    await TrackStore.updateTrack(context, this.trackId, { title: newTitle });
    await this.loadData();
  }

  /** ä¿å­˜ç¼–è¾‘åçš„æ‰“å¡ç‚¹åç§° */
  private async saveEditedSpotName(): Promise<void> {
    const newName = this.editInputText.trim();
    if (newName.length === 0 || this.editingSpotId.length === 0) {
      return;
    }
    this.showEditSpotNameDialog = false;
    const context = this.getUIContext().getHostContext() as common.Context;
    await TrackStore.updateTombSpot(context, this.editingSpotId, { name: newName });
    this.editingSpotId = '';
    await this.loadData();
  }
}
