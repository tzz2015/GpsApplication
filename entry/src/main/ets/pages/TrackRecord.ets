import { router } from '@kit.ArkUI';
import { MapComponent, mapCommon, map } from '@kit.MapKit';
import { AsyncCallback } from '@kit.BasicServicesKit';
import { geoLocationManager } from '@kit.LocationKit';
import { common } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { TrackStore } from '../common/TrackStore';
import { TrackModel } from '../common/TrackModel';
import { SyncService } from '../common/SyncService';

const LOG_DOMAIN = 0x0000;
const LOG_TAG = 'TrackRecord';

/** è·¯ç”±å‚æ•°æ¥å£ */
interface TrackRecordParams {
  trackId: string;
  title: string;
}

/**
 * P1-3 è½¨è¿¹è®°å½•é¡µ
 * å…¨å±åœ°å›¾ + å®æ—¶è½¨è¿¹ + èµ·ç‚¹/æ‰“å¡ç‚¹/æš‚åœç»§ç»­/ç»ˆç‚¹ å®Œæ•´æµç¨‹
 */
@Entry
@Component
struct TrackRecord {
  @StorageProp('statusBarHeight') statusBarHeight: number = 0;
  @StorageProp('bottomSafeHeight') bottomSafeHeight: number = 0;
  // è½¨è¿¹åŸºç¡€ä¿¡æ¯
  private trackId: string = '';
  private trackTitle: string = '';

  // å½•åˆ¶çŠ¶æ€
  @State isRecording: boolean = false;
  @State isPaused: boolean = false;
  @State hasStartPoint: boolean = false;
  @State startPointName: string = '';

  // ç»Ÿè®¡æ•°æ®
  @State totalDistance: number = 0;
  @State currentAltitude: number = 0;
  @State maxAltitude: number = 0;
  @State elapsedTime: number = 0;
  private recordStartTime: number = 0;
  private pauseStartTime: number = 0;
  private totalPausedTime: number = 0;
  private timerInterval: number = -1;

  // æ‰“å¡ç‚¹
  @State tombSpots: TrackModel.TombSpot[] = [];
  @State showSpotPanel: boolean = false;

  // å¼¹çª—
  @State showStartDialog: boolean = false;
  @State showSpotDialog: boolean = false;
  @State showEndDialog: boolean = false;
  @State showInterruptDialog: boolean = false;
  @State dialogInputText: string = '';

  // åœ°å›¾
  @State mapCenterLat: number = 23.7275;
  @State mapCenterLng: number = 108.3426;
  @State showLayerPanel: boolean = false;
  @State currentMapType: number = 1; // 1=æ ‡å‡†, 2=å«æ˜Ÿ, 3=åœ°å½¢
  @State is3DMode: boolean = false;
  private mapOptions?: mapCommon.MapOptions;
  private mapCallback?: AsyncCallback<map.MapComponentController>;
  private mapController?: map.MapComponentController;
  private currentPolyline?: map.MapPolyline;

  // è½¨è¿¹ç‚¹
  private recordPoints: mapCommon.LatLng[] = [];
  private allTrackPoints: TrackModel.TrackPointItem[] = [];
  private lastLat: number = 0;
  private lastLng: number = 0;

  aboutToAppear(): void {
    const params = router.getParams() as TrackRecordParams | undefined;
    if (params) {
      this.trackId = params.trackId || '';
      this.trackTitle = params.title || '';
    }
    this.loadExistingData();
    this.initMap();
  }

  aboutToDisappear(): void {
    this.stopLocationTracking();
    this.stopTimer();
  }

  /** åŠ è½½å·²æœ‰æ•°æ®ï¼ˆç»§ç»­è®°å½•æ—¶ç”¨ï¼‰ */
  private async loadExistingData(): Promise<void> {
    const context = this.getUIContext().getHostContext() as common.Context;
    const track = await TrackStore.getTrackById(context, this.trackId);
    if (track && track.startName.length > 0) {
      this.hasStartPoint = true;
      this.startPointName = track.startName;
      this.totalDistance = track.totalDistance;
      this.maxAltitude = track.maxAltitude;
      if (track.startLat !== 0) {
        this.mapCenterLat = track.startLat;
        this.mapCenterLng = track.startLng;
      }
    }
    this.tombSpots = await TrackStore.getTombSpotsByTrackId(context, this.trackId);

    // åŠ è½½å·²æœ‰è½¨è¿¹ç‚¹
    const points = await TrackStore.getTrackPointsByTrackId(context, this.trackId);
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      this.recordPoints.push({ latitude: p.latitude, longitude: p.longitude });
    }

    // å¦‚æœåœ°å›¾å·²å°±ç»ªï¼Œç§»åŠ¨ç›¸æœºå¹¶ç»˜åˆ¶å·²æœ‰è½¨è¿¹
    if (this.mapController) {
      this.moveCameraTo(this.mapCenterLat, this.mapCenterLng, 16);
      if (this.recordPoints.length >= 2) {
        this.updatePolyline();
      }
    }
  }

  private initMap(): void {
    this.mapOptions = {
      position: {
        target: { latitude: this.mapCenterLat, longitude: this.mapCenterLng },
        zoom: 16
      },
      myLocationControlsEnabled: true,
      scaleControlsEnabled: true
    };
    this.mapCallback = async (err: Error, controller: map.MapComponentController) => {
      if (!err) {
        this.mapController = controller;
        // å¯ç”¨æˆ‘çš„ä½ç½®å›¾å±‚
        try {
          controller.setMyLocationEnabled(true);
        } catch (e) {
          hilog.info(LOG_DOMAIN, LOG_TAG, 'setMyLocationEnabled: %{public}s', JSON.stringify(e));
        }
        // å®šä½åˆ°å½“å‰ä½ç½®
        this.moveToCurrentLocation();
        // ç»˜åˆ¶å·²æœ‰è½¨è¿¹ï¼ˆè‹¥ loadExistingData å·²å®Œæˆï¼‰
        if (this.recordPoints.length >= 2) {
          this.updatePolyline();
        }
      }
    };
  }

  /** WGS84 åæ ‡è½¬ GCJ02ï¼ˆåä¸ºåœ°å›¾ä½¿ç”¨ GCJ02ï¼‰ */
  private async convertToGCJ02(lat: number, lng: number): Promise<mapCommon.LatLng> {
    try {
      const wgs84: mapCommon.LatLng = { latitude: lat, longitude: lng };
      const gcj02: mapCommon.LatLng = await map.convertCoordinate(
        mapCommon.CoordinateType.WGS84,
        mapCommon.CoordinateType.GCJ02,
        wgs84
      );
      return gcj02;
    } catch (e) {
      hilog.error(LOG_DOMAIN, LOG_TAG, 'convertToGCJ02 error: %{public}s', JSON.stringify(e));
      return { latitude: lat, longitude: lng };
    }
  }

  /** ç§»åŠ¨åœ°å›¾ç›¸æœºåˆ°æŒ‡å®š WGS84 åæ ‡ï¼ˆè‡ªåŠ¨è½¬æ¢ä¸º GCJ02ï¼‰ */
  private async moveCameraTo(lat: number, lng: number, zoom: number): Promise<void> {
    if (!this.mapController) {
      return;
    }
    try {
      const gcj02 = await this.convertToGCJ02(lat, lng);
      const cameraPosition: mapCommon.CameraPosition = {
        target: gcj02,
        zoom: zoom,
        tilt: 0,
        bearing: 0
      };
      const cameraUpdate: map.CameraUpdate = map.newCameraPosition(cameraPosition);
      this.mapController.moveCamera(cameraUpdate);
    } catch (e) {
      hilog.error(LOG_DOMAIN, LOG_TAG, 'moveCameraTo error: %{public}s', JSON.stringify(e));
    }
  }

  /** è·å–å½“å‰ä½ç½®å¹¶ç§»åŠ¨åœ°å›¾ */
  private moveToCurrentLocation(): void {
    const request: geoLocationManager.SingleLocationRequest = {
      locatingPriority: geoLocationManager.LocatingPriority.PRIORITY_ACCURACY,
      locatingTimeoutMs: 10000
    };
    geoLocationManager.getCurrentLocation(request).then(async (location: geoLocationManager.Location) => {
      this.mapCenterLat = location.latitude;
      this.mapCenterLng = location.longitude;
      this.currentAltitude = Math.round(location.altitude);
      this.lastLat = location.latitude;
      this.lastLng = location.longitude;

      // è½¬æ¢åæ ‡å¹¶ç§»åŠ¨åœ°å›¾ç›¸æœºåˆ°å½“å‰ä½ç½®
      await this.moveCameraTo(location.latitude, location.longitude, 16);

      // åœ¨åœ°å›¾ä¸Šæ˜¾ç¤ºå½“å‰ä½ç½®æ ‡è®°
      if (this.mapController) {
        try {
          this.mapController.setMyLocationEnabled(true);
          this.mapController.setMyLocation(location);
        } catch (e) {
          hilog.info(LOG_DOMAIN, LOG_TAG, 'setMyLocation: %{public}s', JSON.stringify(e));
        }
      }
    }).catch((e: Error) => {
      hilog.error(LOG_DOMAIN, LOG_TAG, 'getCurrentLocation fail: %{public}s', JSON.stringify(e));
    });
  }

  /** å¼€å§‹æŒç»­å®šä½è®°å½• */
  private startLocationTracking(): void {
    const request: geoLocationManager.ContinuousLocationRequest = {
      interval: 3,
      locationScenario: geoLocationManager.UserActivityScenario.NAVIGATION
    };
    geoLocationManager.on('locationChange', request, (location: geoLocationManager.Location) => {
      if (this.isPaused) {
        return;
      }
      const lat = location.latitude;
      const lng = location.longitude;
      const alt = Math.round(location.altitude);

      // è·ç¦»é˜ˆå€¼è¿‡æ»¤ï¼šè‡³å°‘ç§»åŠ¨2ç±³æ‰è®°å½•
      if (this.lastLat !== 0) {
        const dist = TrackModel.calculateDistance(this.lastLat, this.lastLng, lat, lng);
        if (dist < 2) {
          return;
        }
        this.totalDistance += dist;
      }

      this.lastLat = lat;
      this.lastLng = lng;
      this.currentAltitude = alt;
      if (alt > this.maxAltitude) {
        this.maxAltitude = alt;
      }

      // è®°å½•è½¨è¿¹ç‚¹
      this.recordPoints.push({ latitude: lat, longitude: lng });
      const point: TrackModel.TrackPointItem = {
        pointId: this.trackId + '_pt_' + Date.now(),
        latitude: lat,
        longitude: lng,
        altitude: alt,
        accuracy: location.accuracy || 0,
        timestamp: Date.now(),
        syncStatus: 'pending'
      };
      this.allTrackPoints.push(point);

      // æ›´æ–°åœ°å›¾æŠ˜çº¿
      this.updatePolyline();
    });
  }

  private stopLocationTracking(): void {
    try {
      geoLocationManager.off('locationChange');
    } catch (e) {
      hilog.info(LOG_DOMAIN, LOG_TAG, 'off locationChange: %{public}s', JSON.stringify(e));
    }
  }

  /** æ›´æ–°åœ°å›¾ä¸Šçš„è½¨è¿¹æŠ˜çº¿ï¼ˆWGS84 â†’ GCJ02 è½¬æ¢åç»˜åˆ¶ï¼‰ */
  private async updatePolyline(): Promise<void> {
    if (!this.mapController || this.recordPoints.length < 2) {
      return;
    }
    try {
      if (this.currentPolyline) {
        await this.currentPolyline.remove();
      }
      // å°† WGS84 è½¨è¿¹ç‚¹è½¬æ¢ä¸º GCJ02
      const gcj02Points: mapCommon.LatLng[] = [];
      for (let i = 0; i < this.recordPoints.length; i++) {
        const converted = await this.convertToGCJ02(
          this.recordPoints[i].latitude,
          this.recordPoints[i].longitude
        );
        gcj02Points.push(converted);
      }
      const polylineOption: mapCommon.MapPolylineOptions = {
        points: gcj02Points,
        color: 0xFFFF6B35, // æ©™è‰²è½¨è¿¹çº¿
        width: 14,
        visible: true
      };
      this.currentPolyline = await this.mapController.addPolyline(polylineOption);
    } catch (e) {
      hilog.error(LOG_DOMAIN, LOG_TAG, 'updatePolyline: %{public}s', JSON.stringify(e));
    }
  }

  /** è®¡æ—¶å™¨ */
  private startTimer(): void {
    this.recordStartTime = Date.now();
    this.timerInterval = setInterval(() => {
      if (!this.isPaused) {
        this.elapsedTime = Date.now() - this.recordStartTime - this.totalPausedTime;
      }
    }, 1000);
  }

  private stopTimer(): void {
    if (this.timerInterval !== -1) {
      clearInterval(this.timerInterval);
      this.timerInterval = -1;
    }
  }

  // ==================== ç”¨æˆ·æ“ä½œ ====================

  /** è®¾ç½®èµ·ç‚¹ */
  private async confirmSetStart(): Promise<void> {
    const name = this.dialogInputText.trim() || 'èµ·ç‚¹';
    this.startPointName = name;
    this.hasStartPoint = true;
    this.isRecording = true;
    this.isPaused = false;
    this.showStartDialog = false;
    this.dialogInputText = '';

    // ä¿å­˜èµ·ç‚¹ä¿¡æ¯åˆ°è½¨è¿¹
    const context = this.getUIContext().getHostContext() as common.Context;
    await TrackStore.updateTrack(context, this.trackId, {
      startName: name,
      startLat: this.mapCenterLat,
      startLng: this.mapCenterLng
    });

    // å¼€å§‹å®šä½å’Œè®¡æ—¶
    this.startLocationTracking();
    this.startTimer();
  }

  /** æš‚åœ/ç»§ç»­ */
  private togglePause(): void {
    if (this.isPaused) {
      // ç»§ç»­
      this.totalPausedTime += Date.now() - this.pauseStartTime;
      this.isPaused = false;
    } else {
      // æš‚åœ
      this.pauseStartTime = Date.now();
      this.isPaused = true;
    }
  }

  /** æ·»åŠ æ‰“å¡ç‚¹ */
  private async confirmAddSpot(): Promise<void> {
    const name = this.dialogInputText.trim() || 'æ‰“å¡ç‚¹';
    this.showSpotDialog = false;
    this.dialogInputText = '';

    const context = this.getUIContext().getHostContext() as common.Context;
    const spot: TrackModel.TombSpot = {
      tombId: TrackModel.generateId('tomb'),
      trackId: this.trackId,
      orderIndex: this.tombSpots.length,
      name: name,
      personInfo: '',
      remark: '',
      latitude: this.lastLat,
      longitude: this.lastLng,
      altitude: this.currentAltitude,
      contentText: '',
      imageUris: '[]',
      createdAt: Date.now(),
      updatedAt: Date.now()
    };

    await TrackStore.saveTombSpot(context, spot);
    this.tombSpots.push(spot);

    // ä¿å­˜å·²é‡‡é›†çš„è½¨è¿¹ç‚¹åˆ°æœ¬åœ°
    if (this.allTrackPoints.length > 0) {
      await TrackStore.saveTrackPoints(context, this.trackId, this.allTrackPoints);
      this.allTrackPoints = [];
    }

    // ä¿å­˜è½¨è¿¹ç»Ÿè®¡
    await TrackStore.updateTrack(context, this.trackId, {
      totalDistance: this.totalDistance,
      maxAltitude: this.maxAltitude,
      totalDuration: this.elapsedTime
    });

    // è·³åˆ°æ‰“å¡ç‚¹è¯¦æƒ…é¡µå¡«å†™å›¾æ–‡
    router.pushUrl({
      url: 'pages/TombSpotDetail',
      params: {
        tombId: spot.tombId,
        trackId: this.trackId,
        trackTitle: this.trackTitle,
        fromRecording: true
      }
    });
  }

  /** è®¾ç½®ç»ˆç‚¹å¹¶ç»“æŸè½¨è¿¹ */
  private async confirmSetEnd(): Promise<void> {
    const name = this.dialogInputText.trim() || 'ç»ˆç‚¹';
    this.showEndDialog = false;
    this.dialogInputText = '';

    this.stopLocationTracking();
    this.stopTimer();

    const context = this.getUIContext().getHostContext() as common.Context;

    // ä¿å­˜å‰©ä½™è½¨è¿¹ç‚¹
    if (this.allTrackPoints.length > 0) {
      await TrackStore.saveTrackPoints(context, this.trackId, this.allTrackPoints);
      this.allTrackPoints = [];
    }

    // æ›´æ–°è½¨è¿¹ä¸ºå·²å®Œæˆ
    await TrackStore.updateTrack(context, this.trackId, {
      status: TrackModel.TRACK_STATUS_DONE,
      endName: name,
      endLat: this.lastLat,
      endLng: this.lastLng,
      totalDistance: this.totalDistance,
      totalDuration: this.elapsedTime,
      maxAltitude: this.maxAltitude
    });

    // ç»“æŸè½¨è¿¹åï¼Œåå°åŒæ­¥åˆ°äº‘ç«¯
    SyncService.syncTrack(context, this.trackId).catch((e: Error) => {
      hilog.warn(LOG_DOMAIN, LOG_TAG, 'Sync track after end: %{public}s', JSON.stringify(e));
    });

    // è·³è½¬åˆ°è½¨è¿¹è¯¦æƒ…é¡µ
    router.replaceUrl({
      url: 'pages/TrackDetail',
      params: { trackId: this.trackId, title: this.trackTitle }
    });
  }

  /** ä¸­æ–­è®°å½• */
  private async confirmInterrupt(): Promise<void> {
    this.showInterruptDialog = false;
    this.stopLocationTracking();
    this.stopTimer();

    // ä¿å­˜å½“å‰è¿›åº¦
    const context = this.getUIContext().getHostContext() as common.Context;
    if (this.allTrackPoints.length > 0) {
      await TrackStore.saveTrackPoints(context, this.trackId, this.allTrackPoints);
    }
    await TrackStore.updateTrack(context, this.trackId, {
      totalDistance: this.totalDistance,
      totalDuration: this.elapsedTime,
      maxAltitude: this.maxAltitude
    });

    router.back();
  }

  onPageShow(): void {
    // ä»æ‰“å¡ç‚¹è¯¦æƒ…è¿”å›ååˆ·æ–°æ‰“å¡ç‚¹åˆ—è¡¨
    const context = this.getUIContext().getHostContext() as common.Context;
    TrackStore.getTombSpotsByTrackId(context, this.trackId).then((spots: TrackModel.TombSpot[]) => {
      this.tombSpots = spots;
    });
    if (this.mapController) {
      this.mapController.show();
      // æ¢å¤åé‡æ–°ç»˜åˆ¶å·²æœ‰è½¨è¿¹
      if (this.recordPoints.length >= 2) {
        this.updatePolyline();
      }
    }
  }

  onPageHide(): void {
    if (this.mapController) {
      this.mapController.hide();
    }
  }

  build() {
    Stack() {
    Column() {
      // åœ°å›¾åŒºåŸŸï¼ˆå æ®åº•éƒ¨é¢æ¿ä»¥ä¸Šçš„å…¨éƒ¨ç©ºé—´ï¼‰
      Stack() {
        MapComponent({
          mapOptions: this.mapOptions,
          mapCallback: this.mapCallback
        })
          .width('100%')
          .height('100%');

        // è¿”å›æŒ‰é’®ï¼ˆå·¦ä¸Šè§’ï¼Œè€ƒè™‘çŠ¶æ€æ é«˜åº¦ï¼‰
        Row() {
          Button() {
            Text('â€¹')
              .fontSize(24)
              .fontWeight(FontWeight.Medium)
              .fontColor($r('app.color.label_primary'));
          }
          .width(40)
          .height(40)
          .backgroundColor($r('app.color.card_background'))
          .borderRadius(12)
          .shadow({ radius: 8, color: '#1A000000', offsetX: 0, offsetY: 2 })
          .onClick(() => {
            if (this.isRecording) {
              this.showInterruptDialog = true;
            } else {
              router.back();
            }
          });
        }
        .position({ x: 12, y: 12 + this.statusBarHeight })
        .zIndex(10);

        // åœ°å›¾æ§åˆ¶æŒ‰é’®ï¼ˆå³ä¸Šè§’ï¼‰
        Column({ space: 10 }) {
          // å›¾å±‚åˆ‡æ¢
          Button() {
            Text('ğŸ—º')
              .fontSize(18);
          }
          .width(40)
          .height(40)
          .backgroundColor(this.showLayerPanel ? '#3478F6' : $r('app.color.card_background'))
          .borderRadius(12)
          .shadow({ radius: 8, color: '#1A000000', offsetX: 0, offsetY: 2 })
          .onClick(() => {
            this.showLayerPanel = !this.showLayerPanel;
          });

          // 3D æ¨¡å¼åˆ‡æ¢
          Button() {
            Text(this.is3DMode ? '3D' : '2D')
              .fontSize(13)
              .fontWeight(FontWeight.Bold)
              .fontColor(this.is3DMode ? Color.White : $r('app.color.label_primary'));
          }
          .width(40)
          .height(40)
          .backgroundColor(this.is3DMode ? '#3478F6' : $r('app.color.card_background'))
          .borderRadius(12)
          .shadow({ radius: 8, color: '#1A000000', offsetX: 0, offsetY: 2 })
          .onClick(async () => {
            this.is3DMode = !this.is3DMode;
            if (this.mapController) {
              try {
                const tilt = this.is3DMode ? 45 : 0;
                const lat = this.lastLat !== 0 ? this.lastLat : this.mapCenterLat;
                const lng = this.lastLng !== 0 ? this.lastLng : this.mapCenterLng;
                const gcj02 = await this.convertToGCJ02(lat, lng);
                const cameraPosition: mapCommon.CameraPosition = {
                  target: gcj02,
                  zoom: 16,
                  tilt: tilt,
                  bearing: 0
                };
                const cameraUpdate: map.CameraUpdate = map.newCameraPosition(cameraPosition);
                this.mapController.moveCamera(cameraUpdate);
              } catch (e) {
                hilog.error(LOG_DOMAIN, LOG_TAG, 'moveCamera tilt error: %{public}s', JSON.stringify(e));
              }
            }
          });

          // å®šä½æŒ‰é’®
          Button() {
            Text('ğŸ“')
              .fontSize(18);
          }
          .width(40)
          .height(40)
          .backgroundColor($r('app.color.card_background'))
          .borderRadius(12)
          .shadow({ radius: 8, color: '#1A000000', offsetX: 0, offsetY: 2 })
          .onClick(() => {
            this.moveToCurrentLocation();
          });
        }
        .position({ x: '100%', y: 12 + this.statusBarHeight })
        .translate({ x: -52 })
        .zIndex(10);

        // å›¾å±‚é€‰æ‹©é¢æ¿
        if (this.showLayerPanel) {
          Column() {
            Row({ space: 12 }) {
              this.LayerOption('æ ‡å‡†', '#3478F6', 1);
              this.LayerOption('å«æ˜Ÿ', '#34C759', 2);
              this.LayerOption('åœ°å½¢', '#FF9500', 3);
            }
            .padding(16)
            .backgroundColor($r('app.color.card_background'))
            .borderRadius(12)
            .shadow({ radius: 12, color: '#1A000000', offsetX: 0, offsetY: 4 });
          }
          .position({ x: '100%', y: 160 + this.statusBarHeight })
          .translate({ x: -220 })
          .zIndex(15);
        }
      }
      .width('100%')
      .layoutWeight(1);

      // åº•éƒ¨å½•åˆ¶é¢æ¿ï¼ˆå›ºå®šåœ¨åº•éƒ¨ï¼‰
      Column() {
        // å½•åˆ¶çŠ¶æ€
        if (this.isRecording) {
          Row({ space: 6 }) {
            Circle({ width: 8, height: 8 })
              .fill(this.isPaused ? $r('app.color.warning') : $r('app.color.destructive'));
            Text(this.isPaused ? 'å·²æš‚åœ' : 'å½•åˆ¶ä¸­')
              .fontSize(13)
              .fontWeight(FontWeight.Medium)
              .fontColor(this.isPaused ? $r('app.color.warning') : $r('app.color.destructive'));
          }
          .justifyContent(FlexAlign.Center)
          .width('100%')
          .margin({ bottom: 12 });
        }

        // ç»Ÿè®¡æ•°æ®
        Row() {
          Column() {
            Text(TrackModel.formatDistance(this.totalDistance))
              .fontSize(24)
              .fontWeight(FontWeight.Bold)
              .fontColor($r('app.color.label_primary'));
            Text('è·ç¦»')
              .fontSize(11)
              .fontColor($r('app.color.label_tertiary'));
          }
          .layoutWeight(1)
          .alignItems(HorizontalAlign.Center);

          Column() {
            Text(TrackModel.formatDuration(this.elapsedTime))
              .fontSize(24)
              .fontWeight(FontWeight.Bold)
              .fontColor($r('app.color.label_primary'));
            Text('æ—¶é•¿')
              .fontSize(11)
              .fontColor($r('app.color.label_tertiary'));
          }
          .layoutWeight(1)
          .alignItems(HorizontalAlign.Center);

          Column() {
            Text(this.currentAltitude.toString() + 'm')
              .fontSize(24)
              .fontWeight(FontWeight.Bold)
              .fontColor($r('app.color.label_primary'));
            Text('æµ·æ‹”')
              .fontSize(11)
              .fontColor($r('app.color.label_tertiary'));
          }
          .layoutWeight(1)
          .alignItems(HorizontalAlign.Center);
        }
        .width('100%')
        .margin({ bottom: 16 });

        // å·²æ‰“å¡ç‚¹å¿«æ·å…¥å£
        if (this.tombSpots.length > 0) {
          Row() {
            Text('ğŸ“')
              .fontSize(16);
            Text(`å·²æ·»åŠ  ${this.tombSpots.length} ä¸ªæ‰“å¡ç‚¹`)
              .fontSize(13)
              .fontWeight(FontWeight.Medium)
              .fontColor($r('app.color.label_primary'));
            if (this.tombSpots.length > 0) {
              Text(' Â· ' + this.tombSpots[this.tombSpots.length - 1].name)
                .fontSize(13)
                .fontColor($r('app.color.label_tertiary'))
                .maxLines(1)
                .textOverflow({ overflow: TextOverflow.Ellipsis })
                .layoutWeight(1);
            }
            Blank();
            Text('â€º')
              .fontSize(16)
              .fontColor($r('app.color.label_tertiary'));
          }
          .width('100%')
          .padding(12)
          .backgroundColor($r('app.color.app_background'))
          .borderRadius(10)
          .margin({ bottom: 14 })
          .onClick(() => {
            this.showSpotPanel = !this.showSpotPanel;
          });
        }

        // æ“ä½œæŒ‰é’®
        if (!this.hasStartPoint) {
          // æœªè®¾ç½®èµ·ç‚¹
          Button('è®¾ç½®èµ·ç‚¹å¼€å§‹è®°å½•')
            .width('100%')
            .height(50)
            .fontSize(17)
            .fontWeight(FontWeight.Medium)
            .fontColor($r('app.color.button_primary_text'))
            .backgroundColor($r('app.color.accent'))
            .borderRadius(25)
            .onClick(() => {
              this.showStartDialog = true;
            });
        } else {
          // å·²è®¾ç½®èµ·ç‚¹ï¼šæ‰“å¡ç‚¹ / æš‚åœç»§ç»­ / ç»ˆç‚¹
          Row({ space: 16 }) {
            // æ‰“å¡ç‚¹æŒ‰é’®
            Button() {
              Column({ space: 4 }) {
                Text('ğŸ“')
                  .fontSize(20);
                Text('æ‰“å¡')
                  .fontSize(10)
                  .fontColor($r('app.color.label_secondary'));
              }
            }
            .width(56)
            .height(56)
            .backgroundColor($r('app.color.app_background'))
            .borderRadius(28)
            .onClick(() => {
              this.showSpotDialog = true;
            });

            // æš‚åœ/ç»§ç»­æŒ‰é’®
            Button() {
              Text(this.isPaused ? 'â–¶' : 'â¸')
                .fontSize(24)
                .fontColor(Color.White);
            }
            .width(64)
            .height(64)
            .backgroundColor($r('app.color.accent'))
            .borderRadius(32)
            .shadow({ radius: 12, color: '#33FF6B35', offsetX: 0, offsetY: 4 })
            .onClick(() => {
              this.togglePause();
            });

            // ç»ˆç‚¹æŒ‰é’®
            Button() {
              Column({ space: 4 }) {
                Text('â¹')
                  .fontSize(20);
                Text('ç»ˆç‚¹')
                  .fontSize(10)
                  .fontColor(Color.White);
              }
            }
            .width(56)
            .height(56)
            .backgroundColor($r('app.color.destructive'))
            .borderRadius(28)
            .onClick(() => {
              this.showEndDialog = true;
            });
          }
          .justifyContent(FlexAlign.Center)
          .width('100%');
        }
      }
      .width('100%')
      .padding({ left: 20, right: 20, top: 16, bottom: 16 + this.bottomSafeHeight })
      .backgroundColor($r('app.color.card_background'))
      .borderRadius({ topLeft: 20, topRight: 20 })
      .shadow({ radius: 16, color: '#1A000000', offsetX: 0, offsetY: -4 });

    }
    .width('100%')
    .height('100%');

    // ========== å¼¹çª—ä»¬ï¼ˆå…¨å±è¦†ç›–ï¼‰ ==========

    // è®¾ç½®èµ·ç‚¹å¼¹çª—
    if (this.showStartDialog) {
      this.DialogOverlay('è®¾ç½®èµ·ç‚¹', 'ç¡®è®¤å½“å‰ä½ç½®ä¸ºæ‰«å¢“èµ·ç‚¹', 'ä¾‹å¦‚ï¼šå±±è„šå…¥å£', () => {
        this.confirmSetStart();
      }, () => {
        this.showStartDialog = false;
        this.dialogInputText = '';
      });
    }

    // è®¾ç½®æ‰“å¡ç‚¹å¼¹çª—
    if (this.showSpotDialog) {
      this.DialogOverlay('è®¾ç½®æ‰“å¡ç‚¹', 'å·²è®°å½•å½“å‰ä½ç½®ï¼Œè¯·ä¸ºæ­¤å¢“åœ°ç‚¹å‘½å', 'ä¾‹å¦‚ï¼šç¥–çˆ¶æŸæŸä¹‹å¢“', () => {
        this.confirmAddSpot();
      }, () => {
        this.showSpotDialog = false;
        this.dialogInputText = '';
      });
    }

    // è®¾ç½®ç»ˆç‚¹å¼¹çª—
    if (this.showEndDialog) {
      this.DialogOverlay('è®¾ç½®ç»ˆç‚¹', 'ç¡®è®¤ç»“æŸè½¨è¿¹è®°å½•ï¼Ÿ', 'ä¾‹å¦‚ï¼šå±±è„šå‡ºå£', () => {
        this.confirmSetEnd();
      }, () => {
        this.showEndDialog = false;
        this.dialogInputText = '';
      });
    }

    // ä¸­æ–­ç¡®è®¤å¼¹çª—
    if (this.showInterruptDialog) {
      Column() {
        Column() {
          Text('ä¸­æ–­è®°å½•')
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor($r('app.color.label_primary'))
            .margin({ bottom: 8 });
          Text('å½“å‰è½¨è¿¹æ­£åœ¨è®°å½•ä¸­ï¼Œæ˜¯å¦æš‚æ—¶é€€å‡ºï¼Ÿ\né€€å‡ºåå¯åœ¨è½¨è¿¹è¯¦æƒ…é¡µç»§ç»­è®°å½•ã€‚')
            .fontSize(14)
            .fontColor($r('app.color.label_secondary'))
            .textAlign(TextAlign.Center)
            .lineHeight(22)
            .margin({ bottom: 20 });
          Row({ space: 12 }) {
            Button('ç»§ç»­å½•åˆ¶')
              .layoutWeight(1)
              .height(44)
              .fontSize(15)
              .fontColor($r('app.color.primary'))
              .backgroundColor($r('app.color.primary_light'))
              .borderRadius(22)
              .onClick(() => {
                this.showInterruptDialog = false;
              });
            Button('æš‚æ—¶é€€å‡º')
              .layoutWeight(1)
              .height(44)
              .fontSize(15)
              .fontColor($r('app.color.button_primary_text'))
              .backgroundColor($r('app.color.primary'))
              .borderRadius(22)
              .onClick(() => {
                this.confirmInterrupt();
              });
          }
          .width('100%');
        }
        .width(300)
        .padding(24)
        .backgroundColor($r('app.color.card_background'))
        .borderRadius(20)
        .shadow({ radius: 24, color: '#33000000', offsetX: 0, offsetY: 8 });
      }
      .width('100%')
      .height('100%')
      .backgroundColor('#66000000')
      .justifyContent(FlexAlign.Center)
      .zIndex(100)
      .onClick(() => {
        this.showInterruptDialog = false;
      });
    }
    }
    .width('100%')
    .height('100%');
  }

  @Builder
  LayerOption(label: string, dotColor: string, mapType: number) {
    Column({ space: 6 }) {
      Column() {
        Circle({ width: 24, height: 24 })
          .fill(dotColor);
      }
      .width(52)
      .height(52)
      .borderRadius(10)
      .backgroundColor(this.currentMapType === mapType ? '#EEF3FF' : '#F5F5F5')
      .borderWidth(this.currentMapType === mapType ? 2 : 0)
      .borderColor('#3478F6')
      .justifyContent(FlexAlign.Center);
      Text(label)
        .fontSize(12)
        .fontColor(this.currentMapType === mapType ? '#3478F6' : $r('app.color.label_secondary'));
    }
    .alignItems(HorizontalAlign.Center)
    .onClick(() => {
      this.currentMapType = mapType;
      this.showLayerPanel = false;
      if (this.mapController) {
        try {
          this.mapController.setMapType(mapType);
        } catch (e) {
          hilog.error(LOG_DOMAIN, LOG_TAG, 'setMapType error: %{public}s', JSON.stringify(e));
        }
      }
    });
  }

  @Builder
  DialogOverlay(
    title: string,
    desc: string,
    placeholder: string,
    onConfirm: () => void,
    onCancel: () => void
  ) {
    Column() {
      Column() {
        Text(title)
          .fontSize(18)
          .fontWeight(FontWeight.Bold)
          .fontColor($r('app.color.label_primary'))
          .margin({ bottom: 8 });
        Text(desc)
          .fontSize(14)
          .fontColor($r('app.color.label_secondary'))
          .textAlign(TextAlign.Center)
          .margin({ bottom: 16 });
        TextInput({ placeholder: placeholder, text: this.dialogInputText })
          .onChange((value: string) => {
            this.dialogInputText = value;
          })
          .width('100%')
          .height(44)
          .fontSize(15)
          .backgroundColor($r('app.color.app_background'))
          .borderRadius(10)
          .padding({ left: 12, right: 12 })
          .margin({ bottom: 16 });
        Row({ space: 12 }) {
          Button('å–æ¶ˆ')
            .layoutWeight(1)
            .height(44)
            .fontSize(15)
            .fontColor($r('app.color.primary'))
            .backgroundColor($r('app.color.primary_light'))
            .borderRadius(22)
            .onClick(onCancel);
          Button('ç¡®è®¤')
            .layoutWeight(1)
            .height(44)
            .fontSize(15)
            .fontColor($r('app.color.button_primary_text'))
            .backgroundColor($r('app.color.primary'))
            .borderRadius(22)
            .onClick(onConfirm);
        }
        .width('100%');
      }
      .width(300)
      .padding(24)
      .backgroundColor($r('app.color.card_background'))
      .borderRadius(20)
      .shadow({ radius: 24, color: '#33000000', offsetX: 0, offsetY: 8 });
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#66000000')
    .justifyContent(FlexAlign.Center)
    .zIndex(100);
  }
}
